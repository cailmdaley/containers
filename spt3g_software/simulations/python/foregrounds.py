"""
simulations/python/foregrounds.py

Functions for setting up simulations of gaussian-
and poisson-distributed foregrounds.
"""
import os
import numpy as np
import healpy as hp
from spt3g import core


def get_foreground_sim_spectra(
    freq,
    model='george',
    units='uk',
    thermal_sz=True,
    kinetic_sz=True,
    radio_galaxies=True,
    dusty_galaxies=True,
    dg_clustering=True,
):
    """
    Returns power spectra for the specified foreground(s).

    Parameters
    ----------
    freq : int
        Frequency band. Must be one of 90, 150, or 220
    model : str
        Gaussian foreground model to use. Currently the only supported option
        is 'george' for George et al. 2015 (arXiv: 1408.3161)
    units : str
        Units of output power spectra ('uk' or 'k')
    thermal_sz : bool
    kinetic_sz : bool
    radio_galaxies : bool
    dusty_galaxies : bool
        Populate output dictionary with spectra of each of these foreground
        components
    dg_clustering : bool
        If True, include the clustering term with the dusty galaxy component.
        Only used if `dusty_galaxies` is also True.

    Returns
    -------
    fg_cls : dict
        Contains foreground power spectra of the desired foreground
        component in the desired frequency band.  Keys may include
        'tSZ', 'kSZ', 'RG', 'DG', depending on chosen options above.

    See Also
    --------
    get_foreground_power_George_SPT_2015
    """
    if model != 'george':
        raise NotImplementedError(model)

    fg_cls = {}

    # for gaussian SZ
    if thermal_sz:
        fg_cls['tSZ'] = get_foreground_power_george_2015('tSZ', freq1=freq, units=units)
    if kinetic_sz:
        fg_cls['kSZ'] = get_foreground_power_george_2015('kSZ', freq1=freq, units=units)

    # for gaussian radio
    if radio_galaxies:
        fg_cls['RG'] = get_foreground_power_george_2015('RG', freq1=freq, units=units)

    # for gaussian dusty galaxies
    if dusty_galaxies:
        fg_cls['DG-Po'] = get_foreground_power_george_2015(
            'DG-Po', freq1=freq, units=units
        )

        # dusty galaxies clustering term. get this even if we do poisson
        # realisations to include the clustering term later
        if dg_clustering:
            fg_cls['DG-Cl'] = get_foreground_power_george_2015(
                'DG-Cl', freq1=freq, units=units
            )

    return fg_cls


def get_foreground_power_george_2015(component, freq1=150, freq2=None, units='uk'):
    """
    Foreground powers from George et al. 2015 results.

    Uses .sav file generated by Christain Reichardt.

    Parameters
    ----------
    component : str
        The foreground component to use. Must be one of
        'all', 'tSZ', 'kSZ', 'DG-Cl', 'DG-Po', 'RG', 'tSZ-CIB', 'Total', 'CMB'
    freq1 : int
        Frequency band. If `freq2` is specified, the cross-spectrum between
        the two frequencies will be returned. Otherwise autospectrum of freq1.
    freq2 : int, optional
        Frequency band for cross-spectrum with `freq1`
    units : str
        'k' or 'uk'. Note: default savfile is Dls in uK

    Returns
    -------
    fgnd_cls : array
        Power spectrum of `component` at specified frequency band.
    """
    components = [
        'all',
        'tSZ',
        'kSZ',
        'DG-Cl',
        'DG-Po',
        'RG',
        'tSZ-CIB',
        'Total',
        'CMB',
    ]
    if component not in components:
        raise ValueError(
            '{} not in list of possible foregrounds, must be one of {}'.format(
                component, components
            )
        )

    filename = os.path.join(
        os.path.dirname(__file__), 'data/foregrounds/george_plot_bestfit_line.sav'
    )
    from scipy.io import readsav

    data = readsav(filename)

    if freq2 is None:
        freq2 = freq1
    if freq1 == 90:
        freq1 = 95
    if freq2 == 90:
        freq2 = 95

    freqs = np.asarray(
        [(95, 95), (95, 150), (95, 220), (150, 150), (150, 220), (220, 220)]
    )
    dls_all = data['ml_dls'][(freqs[:, 0] == freq1) & (freqs[:, 1] == freq2)][0]
    labels = data['ml_dl_labels'].astype('str')
    ells = np.asarray(data['ml_l'], dtype=int)

    if component == 'all':
        spec = ells * 0.0
        for fg in components:
            if fg in ['all', 'tSZ-CIB', 'Total', 'CMB']:
                continue
            spec += dls_all[labels == fg][0]
    else:
        spec = dls_all[labels == component][0]

    # Changing Dls to Cls
    spec /= ells * (ells + 1.0) / 2.0 / np.pi
    if units.lower() == 'k':
        spec /= 1e12

    # Pad to l=0
    spec = np.concatenate((np.zeros(min(ells)), spec))

    return spec


def get_poisson_source_counts(
    population,
    freq=150,
    min_flux_limit=6.4e-3,
    max_flux_limit=50e-3,
    rg_model='dezotti',
    dg_model='bethermin',
):
    """
    Get dusty or radio source counts for poisson realisations

    Parameters
    ----------
    population : str
        The radio population for which to get source counts.
        Must be 'radio' for radio galaxies or 'dust' for dusty galaxies.
    freq : int
        frequency band
    min_flux_limit, max_flux_limit : float
        flux limits in Janskys
    rg_model : str
        The model giving source counts and fluxes for radio galaxies.
        Currently the only supported option is 'dezotti' for
        De Zotti et al. 2005 (arXiv: astro-ph/0410709)
    dg_model : str
        The model giving source counts and fluxes for dusty galaxies.
        Currently the only supported option is 'bethermin' for
        BÃ©thermin et al. 2012 (arXiv: 1208.6512)

    Returns
    -------
    fluxes : array_like
        Array of flux values in Jy for the specified population and frequency band
    counts : array_like
        Source count for each flux value in the population
    """
    if freq == 90:
        freq = 95
    if freq not in [95, 150, 220]:
        raise ValueError('freq must be one of 90, 150, 220')

    # first we will get flux range [s] and dN/ds for dusty or radio sources
    if str(population).lower().startswith('radio'):
        # pending - handle different models other than just deZotti
        if rg_model != 'dezotti':
            raise NotImplementedError(rg_model)
        filename = os.path.join(
            os.path.dirname(__file__),
            'data/foregrounds/counts_150GHz_de_Zotti_radio.res',
        )
        log_s, x, y, logs25n = np.loadtxt(filename, skiprows=12, unpack=True)
        # first get the number of sources in each flux range
        s = 10 ** log_s
        s25n = 10 ** logs25n
        dnds = s25n / s ** 2.5

    elif str(population).lower().startswith('dust'):
        # pending - handle different models other than just Bethermin
        if dg_model != 'bethermin':
            raise NotImplementedError(dg_model)
        freq_cib = {95: 100, 150: 143, 220: 217}[freq]
        filename = os.path.join(
            os.path.dirname(__file__),
            'data/foregrounds/Bethermin_model_counts_{}GHz.txt'.format(freq_cib),
        )
        s, dnds = np.loadtxt(filename, usecols=[0, 1], unpack=True)

    else:
        raise ValueError(
            "population must be one of 'radio','dust'; not %s" % population
        )

    lns = np.log(s)
    dlns = lns[1] - lns[0]
    dndlns = dnds * s
    nsources = dndlns * dlns  # number of sources obtained

    # pick sources in the flux limit
    inds = (s > min_flux_limit) & (s <= max_flux_limit)
    return s[inds], nsources[inds]


def make_poisson_source_sim(
    flux, count, freq=150, nside=2048, pol=True, pol_fraction=0.02, units='uk'
):
    """
    Creates Poisson realisation of point sources

    Parameters
    ----------
    flux : array_like
        Source flux in Jy per flux bin in the population dN/dS.
    count : array_like
        Source count corresponding to each of the values in `flux`.
    freq : float
        Observing frequency in GHz.
    nside : int
        healpix nside for sims maps. default is 2048.
    pol : bool
        Make polarised skies. default is True.
    pol_fraction : float
        Source polarization fraction.
    units : str
        If set to 'uk', returned map will be in uK. Otherwise K

    Returns
    -------
    data : array_like, shape (3, npix) or (npix,)
        T healpix map of poisson point sources, or array of TQU maps
        if `pol` is True.

    See Also
    --------
    get_poisson_source_counts
    """
    dx = hp.nside2resol(nside)
    pix_area = dx ** 2.0  # Sr
    source_areas = count * pix_area

    npixels = hp.nside2npix(nside)

    # convert fluxes to output units
    from spt3g.sources.source_utils import mjy_to_uk

    conv = mjy_to_uk(1e3, frequency=freq * core.G3Units.GHz, omega_b=pix_area)
    if units.lower() == 'k':
        conv /= 1e6

    ### pending: currently i am stupidly doing this for each flux bin.
    # Need to be fixed using the below code where i can do this for all
    # bins at once and pick flux values from the dN/dS distribution
    logds = np.log10(flux[1]) - np.log10(flux[0])
    logs = np.log10(flux)
    logs_range = np.column_stack((logs, logs + logds))
    s_range = conv * 10 ** logs_range  # in output units

    tmap = np.zeros(npixels, dtype=float)
    if pol:  # create Q, U maps too
        qmap = np.zeros(npixels, dtype=float)
        umap = np.zeros(npixels, dtype=float)

    # create a source map for each flux bin
    for lam, (s1, s2) in zip(source_areas, s_range):
        current_bin = np.random.poisson(lam, npixels)

        ## now assign fluxes
        non_zero_inds = np.nonzero(current_bin)[0]
        for nn in non_zero_inds:
            # we can approximate the flux value to follow a
            # uniform distribution in each narrow flux bin

            # fluxes in output units
            fluxes = np.random.uniform(s1, s2, size=int(current_bin[nn]))

            # add to output map
            tmap[nn] += np.sum(fluxes)

            if pol:
                P = fluxes * pol_fraction

                # a random pol angle for each source
                pol_angle = np.random.uniform(0.0, 2.0 * np.pi, len(fluxes))
                Q = P * np.cos(2 * pol_angle)
                U = P * np.sin(2 * pol_angle)

                # add to output map
                qmap[nn] += np.sum(Q)
                umap[nn] += np.sum(U)

    if pol:
        return np.asarray([tmap, qmap, umap])
    return tmap
